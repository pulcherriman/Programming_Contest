# AHC027

# 12/3 0:10 開始
ドラクエモンスターズ3のせいですべてが遅れている

## サンプル
サンプルは深さ優先木探索

基本的には（全てが同じDijなら）一度行ったところに戻らないほうがいいはず

そうでなくても、「帰ってくるまでが2手増えると、N^2-1マスにその分汚れがたまる」

→ 手数の短さは正義のはず

## 平均汚れ
平均で考えるとアレなのでL倍して和にする

平均汚れについてガッツリ考えたほうがいい。

壁が1枚しかないケース（ほぼ自由に動ける）を思うと、最適なルート構築には平均汚れの理解が必要

基本的にgは
```
  /    /   Dij*2
 /  / /    Dij
/  / /     0
|      |
時刻t   t+L
```
みたいに鋸歯状になる

平均なんだから手数が長くてもいいじゃん？　みたいな気持ちになるけど...

例えば上の例で最後に2手伸びると,[01201012]/8=0.875 から、[0120101234]/10=1.4になる

これがN^2マスで起きる代わりに、伸ばした分の2マスだけ良くなっても意味がないケースが多いはず

やりたいことは、全てのマスにおいてこの鋸刃の高さを出来るだけ低くすること

Dijが大きいマスほど角度が急なので、Dijが大きいマスをターミナルにして辺りをお掃除する、みたいな感じになる...のか？

## 寄り道した方が良い場合
4x4マスで以下のD
```
1 1 1 1
1 1 1000 1
1 1 1 1
1 1 1 1
```

最短ルートの一例は以下
```
v<<<
v>v^
v^v^
>^>^
```
- `DDDRUURDDRUUULLL`: 7613 に対し、
- `DDDRUURDDRUUULDULL`: 4181
- `RRDRUDLDRDLUULDDLUUU`:3438
- `RRDRUDLDRDLUULDDLUURRLLU`:2825
を達成する。

本当は最低400マスあって、Dijがそこそこ大きいマスも分布しているのでここまで極端にはならないと思いたいが...

部分的には、移動中にクソデカマスが近くにあったときは寄り道して取るといい可能性がある

その2手分の損失の方がデカそうだと思うけどなぁ

## 仮定戦略1
1. 二重辺連結成分分解をする
2. 縮約後の根付木を巡回する必要がある。訪問順はわりとどうでもいい
  1. どの連結成分も一度離れたらその周回中には戻ってこないので
  2. ある成分F内で、始点Sから全マスを通ってSに戻る最適なルートRを構築する
     1. この操作は葉から行う！
  3. 子に接続する頂点を通ったタイミングで、子に寄り道する。
     1. 2-2-1. のとおり葉から行うことで、この時点で全ての子の手数が決まっている
  4. 寄り道によってF内の全頂点が汚れる前提でルート構築する
     1. F内のあるマスVに対し、子との接続頂点Cとその手数Xがある
     2. このときRに関わらず、Vには必ずD_V * (dist(V,C)*2 + X) 以上の汚れがたまる
        1. Vから最速でCとその子に行ってまたVに最速で戻る時。
        2. (V in F, C in Cs) 全対に対して、上式の最大値が、鋸刃の上端の自明な下界

### 実装のために考えること
- Rを1つ定めたとする。あるV in Fに対し、Vへの寄り道による利得と損失を立式したい
  - 寄り道がないなら、あんまり得にならないはずなんだけども。
- 二重頂点連結成分にいい特徴はないか？
- 別に分解しなくてもやってること同じじゃないか？
- グラフに重みを設定すると幸せになれないか？

### とりあえず
- Fをぐるっと1周する最短ルートを構築する
  - これってそんなに簡単か？？？？？


##### 捨てた考察
  1. 連結成分の頂点集合Sに対し、1手ほかの頂点で過ごすとΣs in S : D_s ずつ和が増加していく
    1. 他でX手過ごすと、(Σs in S : D_s) * X * (X+1) / 2 だけ和が増加する
  2. 各連結成分は高々2回しか訪れない（木なので）
     1. 葉でない連結成分では、行きで全てを回る必要はない
           0-1-2
             | |
             3-4-5   では、[0],[1234],[5]に対して、0-124-5-431-0 と回ればいい
  3. 葉でない任意の連結成分に対しては、親への接続頂点Sと子へのそれP1,P2,P3がある

# 12/3 19:00 実装開始
まずはDijを考える前に、短いルートを構築することを考える

可視化のために、Dijを一律同じ値にしたデータで試す
試すのはseed = 0, 19

## 実装したアルゴリズム (main)
元のグラフをG、求める答えをAとする
- Gに二重辺連結成分分解をして、縮約後の木 Gcont を得る
- (0,0)を含む連結成分から始めて以下の処理
  - 現在見ている連結成分Fに対し、成分内を全て通る経路Rを構築する → ルート構築
  - Rを実際にたどりAに追加。Gcont上の隣接ノードに移動可能な頂点があれば以下の処理
    - まだ未訪問の連結成分なら移動。Fを更新
- 処理完了後、Aは(0,0)から全マスを通って(0,0)に戻るルートとなっている

## 実装したアルゴリズム (ルート構築)
連結成分Fとループ構築の始点Sに対し、成分内を全て通る経路Rを構築する
- SからBFSし、最小の閉路を発見する。これをRとする
- 以下の操作を、Rに全頂点が含まれるまで繰り返す
  - R上の各辺V1->V2に対し、辿る順番に以下の処理
    - F内の未到達の頂点V3,V4を使って、V1->V3->V4->V2 と 通れるか判定
      - 通れるなら変更し、V1->V3辺について再度判定
      - 通れないなら次の辺へ
  - 終了後、RはF内のだいたいを通過可能なルートとなっている
    - 通過できないのは主に2パターン
      1. 4方向に隣接する未訪問頂点のない、ちょうど1マスの空白
      2. 2枚の壁で挟まれた、幅1の通路およびその先の空間
  - R上の各頂点V1について、辿る順番に以下の処理
    - F内の未到達の隣接頂点V2があれば、V1->V2->V1 を追加
    - この処理を終了し、V1->V2辺以降に対しはじめの操作を行う
      - TODO: この「はじめの操作」は、一度でも終了したらbreakして良いはずだが怖いのでやってない
- 処理完了後、RはF内の全頂点を通る、概ねいい感じのルートとなっている

## 結果
Seed 0 `N=20`
- Before(サンプルコード) : `3302174, T=798`
- After(初期実装) : `2473002, T=400`

<img src="./0-0.png" style="width: 40%; display: inline;"/>
<img src="./0-1.png" style="width: 40%; display: inline;"/>


Seed 19 `N=40`
- Before(サンプルコード) : `60105356, T=3198`
- After(初期実装) : `36684243, T=1694`

<img src="./19-0.png" style="width: 40%; display: inline;"/>
<img src="./19-1.png" style="width: 40%; display: inline;"/>

## 分析
経路長が半分になったのに伴って、スコアもいい感じに落ちた。

絶対スコアは `1101596079` 、ケースごと平均は `22031921.58`。
- 今後山登りや焼き鈍しをしていくにあたってのvalidな初期解としては十分か？ 実行時間は6ms。

相対スコアは `30,650,224,295` 、146位 (2023/12/4 1:43)。
- 人類強すぎるだろ。勘弁してくれ
- この時、Rafbill氏が `49,957,707,735` とかいう無敵のスコアを出している
  - 50/30=1.67倍悪い。Seed=0なら`1480839`、19なら `21966612` 程度を達成しているとみられる。
    - どのような入力に対しても同様と仮定。Nが大きいケースで顕著、みたいな話はあり得る

## 今後
- まずは山登りしたい　そのためにはスコア計算が必要
  - N=40ターンの時、1600マスに1600ターンの履歴がある
  - 全部持てないので、いい感じにやる
  - 各マスに対し、訪れたターン数だけ持てば、総ターン数を持つことで計算できる
    - 0,Dij, 2Dij, 3Dij, ...(次に訪問するまで) の総和なので
    - 全体でO(ターン数=N^2)で計算できる。
      - 差分更新は、TLEを伸ばすしか手がなってから頑張ればいい
      - ただ、O(1)とか、セグ木でO(log(N^2)) とかで出来る可能性がある
      - 考察して、ここまでオーダー落ちるならやる価値はめっちゃある
- 山登りの差分は、経路作成と同様の2種か。
  - 2要素近傍、1要素近傍
- どれくらい伸びうるか？ だが、ちょっとは変わってくれるはず
  - 現在は基本的に各マス1回しか訪問していない
  - 1回なら、各マスの汚れは Dij * T * (T-1) / 2
    - Seed=0は400手で全マス各1回なので、スコアは入力値からわかる
  - Dijが大きいところに対して、0手目とT/2手目（相対）で訪れるとどうなるか？
    - Dij * (T/2) * (T/2-1) * 2 / 2になる → だいたい半分
  	- 3回(0, T/3, 2T/3)なら、Dij * (T/3) * (T/3-1) * 3 / 2 → だいたい1/3
  - 寄り道ごとにN^2-2マスが2手損失するが、それを抜きにしてもメリットがある
- 基本方針は、経路長を大きく伸ばさないように、大きいマスの隣に来たらつまみ食い
  - 前から順にやっていいのか、効果が大きいモノからやるのがいいのかはわからない
- 上記性質を考えると、「大きい汚れ近辺を」「出来るだけ離れたタイミングで」「複数解通る」初期経路であれば、その分効率の良いつまみ食いが可能...っぽい

# 12/5 1:00 実装
- スコア計算と2要素近傍のみ。結構重い。高速化が必要
  - 近傍のパスをvectorで陽に構築しているのがセンスなさそう

## 結果
Seed 0 `N=20`
- Before(サンプルコード) : `3302174, T=798`
- Before(初期実装) : `2473002, T=400`
- After(2要素近傍貪欲) : `1904182, T=518`

<img src="./0-1.png" style="width: 40%; display: inline;"/>
<img src="./0-2.png" style="width: 40%; display: inline;"/>

Seed 19 `N=40`
- Before(サンプルコード) : `60105356, T=3198`
- Before(初期実装) : `36684243, T=1694`
- After(2要素近傍貪欲) : `35119116, T=1782`

<img src="./19-1.png" style="width: 40%; display: inline;"/>
<img src="./19-2.png" style="width: 40%; display: inline;"/>

## 分析
- スコア上も見た目上も、明らかにSeed=0のほうが改善
  - 大きさなのか、壁の数なのか
- ローカル2000ケース回して、平均*50が `1047887118` から `897982935` に
- 提出時のスコアは `1101596079` から `971837477` 。187th → 129th (35046M)
  - 人類強すぎるだろ。勘弁してくれ
    - この時もRafbill氏が無敵
      - 50/35=1.43倍悪い。が、恐らくSeed=0みたいなのはそこそこ戦えてて、19みたいなので大きく失点してる
  - とはいえ、点数の改善に対して順位の上り幅が思ったより大きかった
    - 60thで39.7G。どうせもっとエグいことになるだろうが...
- 壁が多いケースは、なんなら悪化までしている（右下とか）
  - 現状Gcontの要素は各1回ずつしか訪れていないが、重い領域を複数回訪れてみたい
    - 2回目以降の訪問時は、道中は汚れ量を見ながら最短経路とかでもいいはず
      - 大きいFの中に部分的に重い領域があるような場合、2回目の訪問で該当領域に到着したところを端として、領域内をもう一回走らせてみる？
    - でも辿り着きさえすれば、既存の近傍アルゴリズムで伸ばせるはず
- 高速化したい。2要素近傍1周で提出して300msec掛かってる
  - なお、ローカルではSeed=19が540msに対し、コードテストでは76ms。
  - この差があって300msということは、ローカルで2秒近くかかっているケースがありそう

# 12/7 8:00 むり～～～
183rdまで落ちてる。進捗の気配はあんまりない！w

## スコア計算を軽く
- なんか適当に書き直したらスコア計算100倍速になった
  - これは前の適当実装が悪かっただけ
  - 1要素近傍も入るようになった
    - 寄与は大きくなさそうなので、探索範囲を広げるためにパスしてもいいかも！

## 泣きながら実装
- 重いところを刺していく。
  - スコアへの（悪い意味での）寄与が最も大きい場所を探して、その中間地点で再度訪問する
  - 100手目と800手目に通ってる場所なら、450手目の地点で無理やりその場所まで行って戻る経路を追加する
- 1箇所刺すだけだと効率が悪いが、そこから件の2要素近傍で近辺を大体食べつくせる

## 結果
Seed 0 `N=20`
- Before(サンプルコード) : `3302174, T=798`
- Before(初期実装) : `2473002, T=400`
- Before(2要素近傍貪欲) : `1904182, T=518`
- After(最悪地点訪問) : `1672971, T=872`

<img src="./0-2.png" style="width: 40%; display: inline;"/>
<img src="./0-3.png" style="width: 40%; display: inline;"/>

Seed 19 `N=40`
- Before(サンプルコード) : `60105356, T=3198`
- Before(初期実装) : `36684243, T=1694`
- Before(2要素近傍貪欲) : `35119116, T=1782`
- After(最悪地点訪問) : `30523885, T=2652`

<img src="./19-2.png" style="width: 40%; display: inline;"/>
<img src="./19-3.png" style="width: 40%; display: inline;"/>

## 分析
- 両方2割弱の改善。でっっっか
- 絶対スコアは `793315115` 、相対スコアは `41.85M`
  - 61stまで上がった（書いてるときには71まで落ちてるけどな）
- もうあたまはたらかな～～い！


# 12/8 4:30 ？？？？？
- 適当な差分書いて適当に提出したら `772768376` になった
  - 相対 `42.82M` 。絶対スコアの改善の割に相対の伸びが大きい？
  - つまりテストケースの運がいいだけ？
  - ちなみに、ローカル2000ケースの50平均は `719901170`
- なにしたんだっけ？　風呂入ったら忘れた
  - 「100手目と800手目に通ってる場所なら、450手目の地点で」を変えた
  - 450手目の場所だと、目標地点が遠い時がある
  - 基本的には、2N手あればどこにでも行けるので、400~500手目くらいのどこかのほうが寄り道しやすいかも！
  - 現状ターン数が2(N^2)くらいまで伸びてきているので、長さを抑えることが大事だったりするかも
- こんだけ伸びると、0~N^2手くらいまでの全マス走査（のうち、Dが小さい部分）が不要になってるかも？
  - 削除近傍もあると伸びるかもしれない？
- そんなことより、探索回数が少なすぎる
  - 40回しか回ってないw


# 12/9 3:00 終わってる
- ローカル2000ケース動くのに、submitすると一個だけREを吐く
- ローカルでも、ちょっと書き換えるといろんなところでsegvとかdouble freeとか吐いたりする
  - 都度修正しているが、毎回出てくる場所がちがうんだよな...
- 削除近傍を適当に実装した
  - 749471305

# 12/9 19:30 おわった
- 本質改善が厳しい
  - 探索回数の少なさがボトルネックに
    - 2要素近傍を逐次計算できそうなんだけど、頭がおかしくなっちゃう
- ローカル2000ケース実行、普通に10分かかるんだよな









# 今後に向けて
- tester.pyの整備
  - debug出力でtqdmがキモくなる
    - → tester実行時に-D_DEBUGなしで動かすようにしたい
  - 2000ケース回した後に1ケース目で制約違反とか言われるとキモい
    - → テストケース実行と評価は同時に回す
  - min,maxが消えてる？
- いくつかmakeを足したい
  - gdbデバッグ用のコマンドと動かし方
	```
	g++  -std=gnu++23 -Wall -Wno-unknown-pragmas -O2 -D_DEBUG -I../../lib -pg  main.cpp && gdb ./a.exe

    run < ../../in.txt

	```
  - profiler実行
    ```
	g++  -std=gnu++23 -Wall -Wno-unknown-pragmas -O2 -D_DEBUG -I../../lib -pg  main.cpp  && ./a.exe < ../../in.txt && gprof ./a.exe ./gmon.out > prof.txt 
	```
    - evaluateみたいなタスク生やして叩けるようにしたい
  - 上記はそもそも付け焼刃なので、ちゃんとオプションとか勉強する
- 
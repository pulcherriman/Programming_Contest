#ABC285 結果
Rated A~F 48:51 >>> 48th <<<
perf.2400 (1929 → 1986)

A 0:38
 制約がA<B(やさしい) A==B/2

B 3:55 (+3:17)
 読解Ex 試す

C 6:01 (+2:06)
 26進数

D 14:07 (+8:06)
 辺を張って閉路があったらダメ
 なんか文字列to数値のエンコードに時間かけてた


E 28:31 (+14:24)
 初日を休みとすればいいので、端がループしている...みたいな話は考えなくてよい。
 また連休は不要なので、全体としては「休x1 + 勤x?」を繰り返す感じになる。

 「休勤勤 休勤勤勤」と「休勤勤勤 休勤勤」は答えが一緒。
 つまるところ「何連勤がいくつあるか」だけが重要

 「score[i] = i連勤の生産量」は、「A1 + A1 + A2 + A2 + A3 + ...」と表せる。
 「DP[i] = 全体がi日間の時の答え」とすると、追加でj+1日あればscore[j]貰えるので単純なDP


F 48:51 (+20:20)
 文字列中の各文字の出現回数をカウントした長さ26の列を「頻度列」と呼ぶ

 判定部分を以下のように言い換える
 - S[l:r] が昇順
 - S[l:r]の頻度列が、S全体の頻度列に内包されている
  - S="AAABCDD" → {3,1,1,2,0...} に対して、S[2:6]="AABCD" → {2,1,1,1,0...}は内包
  - 部分列の頻度列の両端の数字だけ減少を許して一致しているか

 昇順判定はUpdate-Minのセグ木に隣接要素が昇順かどうかを入れる
 頻度列はAdd-Sumのセグ木を26本持てばOK


G -
 絶対にフロー。未だに最大流も説明できない雑魚なので何もわからん





#ABC285 結果
Rated A~F 48:51 48th!

A: 制約がA<B、やさしい
B: 読解Ex
C: 26進数
D: 閉路の有無
E: 初日を休み、連休はなしとして良い。連勤数だけが大事。DP
F: 部分列が昇順で、各文字の個数がいい感じならOK。セグ木を27本
G: 絶対フローだコレ! 未だに最大流も説明できない雑魚なので解けません
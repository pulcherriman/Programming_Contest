M以外ACの94点でエキスパート！
ABC: 言われたことをやる
D: 尺取り法
E: 両端キューでシミュレーション
F: 実装こじらせた...シミュレーション
G: 辺を優先度付きキューに入れてみていく。後から気づいたけどほぼPrim法
H: 安い順M個を初期解として、缶切りが必要な一番高いものを削除、缶切りが不要な一番安いものを追加して更新していく
I: dp[i][j][k]=座標(i,j)時点でk個置いたときの答え
J: XとYを個別に計算する。Yは自明。差の二乗和の最小化は平均値。
K: dp[i][j]=i番目まで、mod100でj円支払い済の時の価値の最大値
L: 円の使用不使用を全探索したうえで最小全域木
M: こんな典型っぽい見た目してるのに解けなかった。くやしい。
N: a/bが大きい、同じならaが大きい順にソートして、DP[i][j]=i番目まで見て体力をj使った時の答え（嘘かも）
O: おおむね木なので、大体MST上の経路長が答えになりそう。
   ただ、高々11本の辺が閉路を作っていて最短経路を更新する可能性がある
   （辺の使用有無でbitDPか？と思ったけどまとまらず）
   適当なMSTをとって、余った辺の両端の集合をUとする。
   クエリ(a,b)に対して、(s,t)∈(U,U)で全探索。答えはa->s->t->bの距離の和の最小値と表せる
   a->sとt->bの最短路はMST上の経路と一致するのでLCA
   s->tは、元のグラフでs始点でダイクストラを回せばいい、高々22回